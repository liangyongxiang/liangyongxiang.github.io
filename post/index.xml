<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on yongxiang</title><link>https://liangyongxiang.github.io/post/</link><description>Recent content in Posts on yongxiang</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 20 Jan 2022 20:56:56 +0800</lastBuildDate><atom:link href="https://liangyongxiang.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Gentoo Bump</title><link>https://liangyongxiang.github.io/p/gentoo-bump/</link><pubDate>Thu, 20 Jan 2022 20:56:56 +0800</pubDate><guid>https://liangyongxiang.github.io/p/gentoo-bump/</guid><description>在使用Gentoo的时候，经常看到了某个软件的上游发布了新版本，隔壁arch的小伙伴都用上了，但是Gentoo这边还用不了，心痒难耐。 这时候推荐自己亲自动手上，bump到新的版本真的非常容易。
例如今天有小伙伴说wps都更新到11.1.0.10920了，gentoo-zh这边还是旧的，其实 天苯的overlay 里面已经有新版了，假装没看到，（逃
因为大家的gentoo-zh overlya的配置不一定一样，有的喜欢直接使用原始的git仓库，有的喜欢使用gentoo-mirror的仓库，所以bump的操作会有细微的差异。
在我这里是：
$ git -C /var/db/repos/gentoo-zh remote -v local git@github.com:liangyongxiang/gentoo-zh.git (fetch) local git@github.com:liangyongxiang/gentoo-zh.git (push) origin git@github.com:microcai/gentoo-zh.git (fetch) origin git@github.com:microcai/gentoo-zh.git (push) 如果你使用的是非mirror的仓库，在想给gentoo-zh发pr的时候，也可以直接在里面修改。
不过我先介绍更通用的方式，即先在自己的overlay里bump并且测试好，然后才在gentoo-zh里提交发pull request
在自己的overlay里bump测试 需要有自己的overlay 复制已有的ebuild到自己的overly 安装运行测试 提交修改 自定义overlay 如果没有自己的本地overlay，可以自定义overlay，官方Wiki介绍在这里：https://wiki.gentoo.org/wiki/Creating_an_ebuild_repository。
简单来说就是：
root # eselect repository create local # 自定义本地overlay root # cd /var/db/repos/local/ root # git init # 使用git管理自己的overlay，非必须但是强烈推荐 root # git add . root # git commit -m &amp;#39;create overlay&amp;#39; 复制想要bump的ebuild到你的overlay 这里以gentoo-zh的wps为例，当前gentoo-zh里wps的版本是11.</description></item><item><title>WM学习</title><link>https://liangyongxiang.github.io/p/wm%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 01 Jan 2021 01:39:10 +0800</pubDate><guid>https://liangyongxiang.github.io/p/wm%E5%AD%A6%E4%B9%A0/</guid><description>TINYWM 我现在用的wm是dwm, 它是linux的一个极简的窗口管理器。基于C语言，大概只有2000行的代码。 不过它还不是最简单的窗口管理器。最简单的窗口管理器是tinywm: http://incise.org/tinywm.html。源码如下，我稍微整理一下格式：
/* TinyWM is written by Nick Welch &amp;lt;mack@incise.org&amp;gt;, 2005. * * This software is in the public domain * and is provided AS IS, with NO WARRANTY. */ #include &amp;lt;X11/Xlib.h&amp;gt; #define MAX(a, b) ((a) &amp;gt; (b) ? (a) : (b)) int main() { Display * dpy; Window root; XWindowAttributes attr; XButtonEvent start; XEvent ev; if(!(dpy = XOpenDisplay(0x0))) return 1; root = DefaultRootWindow(dpy); XGrabKey(dpy, XKeysymToKeycode(dpy, XStringToKeysym(&amp;#34;F1&amp;#34;)), Mod1Mask, root, True, GrabModeAsync, GrabModeAsync); XGrabButton(dpy, 1, Mod1Mask, root, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None); XGrabButton(dpy, 3, Mod1Mask, root, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None); for(;;) { XNextEvent(dpy, &amp;amp;ev); if(ev.</description></item></channel></rss>